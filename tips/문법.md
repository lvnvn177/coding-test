1. 숫자 ↔ 문자열 변환
1) 숫자 → 문자열
Integer.toString(n)

2) 문자열 → 숫자
Integer.parseInt(s)

2. String 자르기
1) 문자열을 잘라서 배열에 저장
String[] s = str.split("")을 사용해 문자열을 하나씩 잘라 배열에 바로 저장

2) 문자열을 잘라서 char[]형 배열에 저장
char[] arr = str.toCharArray()을 사용해 문자열을 하나씩 잘라 char형 배열에 바로 저장

3. String[]을 문자열로 출력하기
String.join("",arr) : arr를 ""안의 문자로 연결해 문자열로 출력해준다.

4. String을 뒤집어서 출력하기
StringBuilder를 생성해 String을 뒤집어서 출력

StringBuilder sb = new StringBuilder();
sb.append(s); // 문자열 s추가
sb.reverse(); // 문자열 뒤집기
System.out.println(sb.toString()); // toString()을 이용해 String으로 쓸 때 사용해준다.
5. 배열 처리하기
배열 정렬

// 오름차순 정렬
Arrays.sort(arr) 

// 내림차순 정렬 
int[] arr = {89, 12, 27};
Integer[] arr2 = Arrays.stream(arr).boxed().toArray(Integer[]::new);
Arrays.sort(arr2, Collections.reverseOrder()); // int[]로 선언된 배열은 정렬되지 않음
배열에서 중복된 값 제거하기
Arrays.stream(arr).distinct().toArray()

배열 분할하기
Arrays.copyOfRange(arr, n, m) : arr의 n번째 부터 m-1번째 배열 반환

2차원 배열 정렬하기

int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};

// 1. Comparator 익명 클래스 구현
Arrays.sort(arr, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
        //return o2[0]-o1[0]; // 첫번째 숫자 기준 내림차순 {5,40}{4,20}{3,50}{2,10}{1,30}
        //return o1[1]-o2[1]; // 두번째 숫자 기준 오름차순 {2,10}{4,20}{1,30}{5,40}{3,50}
        //return o2[1]-o1[1]; // 두번째 숫자 기준 내림차순 {3,50}{5,40}{1,30}{4,20}{2,10}
    }
});

// 다중 조건 
int[][] arr2 = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10},{6,40},{6,50},{6,10},{6,20},{6,30}};

Arrays.sort(arr2, new Comparator<int[]>() { 
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0]!=o2[0] ? o1[0]-o2[0] : o1[1]-o2[1]; 
        // 첫번째 기준 오름차순 > 두번째 기준 오름차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,10}{6,20}{6,30}{6,40}{6,50}
        //return o1[0]!=o2[0] ? o1[0]-o2[0] : o2[1]-o1[1]; 
        // 첫번째 기준 오름차순 > 두번째 기준 내림차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,50}{6,40}{6,30}{6,20}{6,10}
    }
});

2. Lambda 사용 - Java 8이상
int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};

Arrays.sort(arr, (o1, o2) -> {
    return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
});
6. 수학 함수
Math.pow(a,b) // a의 b제곱
Math.sqrt(n) // n의 제곱근
Arrays.stream(arr).sum() // 배열 arr의 합
Arrays.stream(arr).average().orElse(0) // 배열 arr의 평균, average()가 리턴한 값이 없을 경우, null 대신 0을 리턴
Math.min(a,b) // a, b중 작은 값 리턴
Math.max(a,b) // a, b중 큰 값 리턴
7. String 함수
str.split("") // str을 ""안의 문자로 분리해서 String[] 배열 반환

str.equals("abc") // 문자열 비교
str.repeat(n) // str을 n번 반복

str.replace("one", "1" , n) // "one"을 "1"로 n번 변경, 만약 n을 쓰지 않는다면 모든 "one"이 변경

str.substring(2, 4) // 2~3 위치의 문자열 반환
str.substring(3) // 3부터 끝까지의 문자열 반환

str.toLowerCase() // 대문자를 모두 소문자로 변경
str.toUpperCase() // 소문자를 모두 대문자로 변경

str.charAt(i) // i번째 문자를 반환, 반환값은 char형

str.compareTo("abcdd")
/*
str과 abcdd가 같으면 0
str이 abcdd보다 사전순으로 앞이면 -1
str이 abcdd보다 사전순으로 뒤면 1
str과 abcdd가 마지막 문자만 다르면 마지막 문자의 사전순 차이 반환 (여기선 1)
*/

Integer.toString(200) // 숫자를 문자열로
Integer.parseInt("200") // 문자열을 숫자로
8. Character 함수
Character.toString(c) // char형 변수 c를 string으로

Character.compare(n1, n2) // char형 n1와 n2를 비교, 같으면 0을 출력. 그냥 출력하게 되면 n1-n2 값을 반환한다.

Character.isUpperCase(c) // c가 대문자인지 판단
Character.isLowerCase(c) // c가 소문자인지 판단

Character.isDigit(s) // 문자 s가 숫자이면 true, 아니면 false 반환
Character.isAlphabetic(s) // 문자 s가 알파벳이면 true, 아니면 false 반환
9. List 함수
list.add(n) // list의 가장 뒤에 n 삽입
list.add(1, n) // 1위치에 n 삽입
list.addAll(list2) // list의 뒤에 list2의 모든 값 삽입

list.remove(3) // 3위치의 값 삭제
list.remove("kang") // 첫번째 kang 삭제
list.removeAll(list2) // list에서 list2에 들어있는 모든 값을 삭제
list.retainAll(list2) // list에서 list2에 들어있는 값을 제외한 모든 값을 삭제

list.size() // 리스트 크기 반환

Collections.sort(list); // 오름차순 정렬
Collections.reverse(list); // 내림차순 정렬 
10. HashMap 함수
HashMap: <key, value>쌍. 특정 규칙 없이 출력됨
LinkedHashMap: <key, value>쌍. 키값이 입력순으로 정렬되어 출력됨
TreeMap: <key, value>쌍. 키값이 알파벳순(오름차순)으로 정렬된 상태로 출력됨

HashMap<Integer, String> map = new HashMap<>();

map.put(1, "사과")
map.put(2, "바나나")
map.put(1, "포도") // key 1이 이미 존재하면 key 1의 value가 "포도"로 대체

map.remove(1) // key 값으로만 요소 삭제 가능
map.clear() // 전체 삭제

map.containsKey(1) // key 값 중 1이 있으면 true, 없으면 false
map.containsValue("사과") // value 중 "사과"가 있으면 true, 없으면 false

// 값 출력
// 방법 1
for (Integer i : map.keySet())
	System.out.println(i + map.get(i)); // 1 사과

// 방법 2 : key와 value가 모두 필요할 때 주로 사용
for (Map.Entry<Integer, String> entry : map.entrySet())
	System.out.println(entry.getKey() + entry.getValue()); // 1 사과
11. PriorityQueue 함수
PriorityQueue<Integer> pq = new PriorityQueue<>();
// 기본은 낮은 숫자가 우선순위를 갖는다.
// 높은 숫자가 우선되게 하려면 () 안에 Collections.reverseOrder() 작성

pq.add(1) // 값 추가, 큐가 꽉 찬 경우 에러 발생
pq.offer(1) // 값 추가, 값 추가 실패시 false 반환
pq.poll() // 첫 번째 값 반환하고 제거, 비어있으면 null 반환
pq.remove() // 첫 번째 값 반환하고 제거, 비어있으면 에러 발생
pq.clear() // 값 모두 삭제 (초기화)
pq.peek() // 첫 번째 값 출력 (제거 X)
pq.size() // 원소 개수 반환
12. 형 변환
// 1) List를 정수 배열로 변환
List<Integer> list = new ArrayList<>();
int[] arr = list.stream().mapToInt(i->i).toArray();

// 2) 정수 배열을 List로 변환 - 1
int[] arr = {89, 12, 27};
List<Integer> list = new ArrayList<>();

for(Integer i : arr){
	list.add(i);
}

// 2) 정수 배열을 List로 변환 - 2
import java.util.*;
import java.util.stream.Collectors;

int[] arr = new int[] {};
List<Integer> list = Arrays.stream(arr).boxed().collect(Collectors.toList());
// Collections.reverse(list); // 리스트 뒤집을 때 사용

// 3) String 배열을 List로 변환
String[] arr = {"A","B","C"};
List<String> list = new ArrayList<>(Arrays.asList(arr));

// 4) List를 String 배열로 변환
List<String> list = new ArrayList<>();

String[] arr = list.stream().toArray(String[]::new); // 두가지 방법 중 하나 아무거나 이용하면 된다.
String[] arr = list.toArray(new String[list.size()]);
13. 진법 변환
n진수 → 10진수

int num = Integer.parseInt(s,n); // 문자열 s를 n진법으로 변환
10진수 → n진수

String s = Integer.toString(num,n); // 숫자 num을 n진법으로 (String 반환)
10진수를 2진수로 변환 (연산)

String s = Integer.toBinaryString(9); // 숫자 9를 문자열 1001으로 반환
String s2 = Integer.toBinaryString(9|30); // 9와 30을 이진수 OR연산을 한 값을 반환
14. Comparator 를 이용한 Arrays.sort() 커스터마이징
참고 블로그
https://st-lab.tistory.com/112

compare를 다시 정의 해주는데, return 값이 양수일 때만 자리를 바꾼다.

15. 배열을 분할하는 법
string은 substring을 이용하여 분할이 가능한데, 배열은 불가능하다. Arrays.copyOfRange() 메소드를 통해 복사한다.

int[] arr = {1, 2, 3, 4, 5}
Arrays.copyOfRange(arr, 2, 5); // 2번째부터 4번째 수의 배열 [3, 4, 5]